"""\
this file contains any functions calling the API
"""

from __future__ import annotations

from typing import Any
from typing import cast
from typing import Dict
from typing import List
from typing import Optional
from typing import Union
from uuid import UUID

from kleinkram.api.client import AuthenticatedClient
from kleinkram.errors import CorruptedFile
from kleinkram.error_handling import AccessDeniedException
from kleinkram.models import Project, File
from kleinkram.models import User
from kleinkram.tag import DataType
from kleinkram.tag import TagType
from kleinkram.utils import is_valid_uuid4
from kleinkram.models import UploadAccess
from kleinkram.models import Mission

MAX_PAGINATION = 10_000

TEMP_CREDS = "/file/temporaryAccess"
CLAIM_ADMIN = "/user/claimAdmin"

PROJECT_BY_NAME = "/project/byName"
PROJECT_BY_ID = "/project/one"
PROJECT_CREATE = "/project/create"
PROJECTS_FILTERED = "/project/filtered"

MISSION_BY_NAME = "/mission/byName"
MISSION_BY_ID = "/mission/one"
MISSION_CREATE = "/mission/create"

TAG_TYPES = "/tag/all"
TAG = "/tag"

ALL_USERS = "/user/all"
USER_INFO = "/user/me"
PROMOTE_USER = "/user/promote"
DEMOTE_USER = "/user/demote"

FILE_DOWNLOAD = "/file/download"
FILE_QUERY = "/file/filteredByNames"
FILE_ONE = "/file/one"
FILE_CONFIRM_UPLOAD = "/queue/confirmUpload"
FILE_OF_MISSION = "/file/ofMission"


def get_upload_creditials(
    client: AuthenticatedClient, internal_filenames: List[str], mission_id: UUID
) -> Dict[str, UploadAccess]:
    if mission_id.version != 4:
        raise ValueError("Mission ID must be a UUIDv4")
    dct = {
        "filenames": internal_filenames,
        "missionUUID": str(mission_id),
    }
    resp = client.post(TEMP_CREDS, json=dct)

    if resp.status_code >= 400:
        raise ValueError(
            "Failed to get temporary credentials. Status Code: "
            f"{resp.status_code}\n{resp.json()['message'][0]}"
        )

    breakpoint()

    raise NotImplementedError("TODO: implement this")

    return resp.json()  # type: ignore


def claim_admin(client: AuthenticatedClient) -> None:
    """\
    the first user on the system could call this
    """
    response = client.post(CLAIM_ADMIN)
    response.raise_for_status()
    return


def get_project(
    client: AuthenticatedClient, identifier: Union[str, UUID]
) -> Union[tuple[UUID, Dict[str, Any]], tuple[None, None]]:

    if isinstance(identifier, UUID):
        params = {"uuid": str(identifier)}
    else:
        params = {"name": identifier}

    resp = client.get("/missions", params=params)

    if resp.status_code in (403, 404):
        return None, None

    # TODO: handle other status codes
    resp.raise_for_status()

    details = resp.json()
    return UUID(details["uuid"], version=4), details


def create_project(
    client: AuthenticatedClient,
    project_name: str,
    *,
    description: str | None = None,
    check_exists: bool = False,
) -> UUID:
    """\
    creates a new mission with the given name and project_id

    if check_exists is True, the function will return the existing mission_id,
    otherwise if the mission already exists an error will be raised
    """
    if description is None:
        description = "autogenerated by CLI"

    if check_exists:
        project_id, _ = get_project(client, project_name)
        if project_id is not None:
            return project_id

    if is_valid_uuid4(project_name):
        raise ValueError(
            f"Project name: `{project_name}` is a valid UUIDv4, "
            "project names must not be valid UUIDv4's"
        )

    resp = client.post(
        MISSION_CREATE,
        json={
            "name": project_name,
            "description": description,
            "requiredTags": [],
        },
    )

    if resp.status_code >= 400:
        raise ValueError(
            f"Failed to create project. Status Code: "
            f"{str(resp.status_code)}\n"
            f"{resp.json()['message'][0]}"
        )

    return UUID(resp.json()["uuid"], version=4)


def get_projects_filtered(client: AuthenticatedClient) -> list[Project]:
    resp = client.get(PROJECTS_FILTERED)
    resp.raise_for_status()

    ret = []
    for project in resp.json()[0]:
        id = UUID(project["uuid"], version=4)
        name = project["name"]
        description = project["description"]

        ret.append(Project(id=id, name=name, description=description))
    return ret


def get_mission_id_by_name(
    client: AuthenticatedClient, mission_name, project_id: UUID
) -> Optional[UUID]:
    params = {"name": mission_name, "projectUUID": str(project_id)}
    resp = client.get(MISSION_BY_NAME, params=params)

    if resp.status_code in (403, 404):
        return None

    # TODO: handle other status codes
    resp.raise_for_status()

    data = resp.json()

    return UUID(data["uuid"], version=4)


def get_mission_by_id(
    client: AuthenticatedClient, mission_id: UUID
) -> Optional[Mission]:
    params = {"uuid": str(mission_id), "take": MAX_PAGINATION}
    resp = client.get(FILE_OF_MISSION, params=params)

    if resp.status_code in (403, 404):
        return None

    resp.raise_for_status()
    data = resp.json()[0]
    files = [_parse_file(file) for file in data]

    resp = client.get(MISSION_BY_ID, params={"uuid": str(mission_id)})
    resp.raise_for_status()

    mission_data = resp.json()
    mission = Mission(
        id=mission_id,
        name=mission_data["name"],
        project_id=UUID(mission_data["project"]["uuid"], version=4),
        files=files,
    )

    return mission


def get_project_id_by_name(
    client: AuthenticatedClient, project_name: str
) -> Optional[UUID]:
    params = {"name": project_name}
    resp = client.get(PROJECT_BY_NAME, params=params)

    if resp.status_code in (403, 404):
        return None

    resp.raise_for_status()

    return UUID(resp.json()["uuid"], version=4)


class MissionExistsError(Exception): ...


def create_mission(
    client: AuthenticatedClient,
    project_id: UUID,
    mission_name: str,
    *,
    tags: Optional[Dict[str, str]] = None,
    ignore_missing_tags: bool = False,
) -> UUID:
    """\
    creates a new mission with the given name and project_id

    if check_exists is True, the function will return the existing mission_id,
    otherwise if the mission already exists an error will be raised
    """

    if get_mission_id_by_name(client, mission_name, project_id) is not None:
        raise MissionExistsError(f"Mission with name: `{mission_name}` already exists")

    if is_valid_uuid4(mission_name):
        raise ValueError(
            f"Mission name: `{mission_name}` is a valid UUIDv4, "
            "mission names must not be valid UUIDv4's"
        )

    payload = {
        "name": mission_name,
        "projectUUID": str(project_id),
        "requiredTags": tags or {},
        "ignoreTags": ignore_missing_tags,
    }
    resp = client.post(MISSION_CREATE, json=payload)
    resp.raise_for_status()

    return UUID(resp.json()["uuid"], version=4)


def get_project_permission_level(client: AuthenticatedClient, project_id: UUID) -> int:
    """\
    we need this to check if a user has the permissions to
    create a mission in an existing project
    """

    resp = client.get("/user/permissions")
    resp.raise_for_status()

    project_group: List[Dict[str, Union[str, int]]] = resp.json().get("projects", [])
    filtered_by_id = filter(lambda x: x.get("uuid") == str(project_id), project_group)

    # it is possilbe that a user has access to a project via multiple groups
    # in this case we take the highest permission level
    return cast(int, max(map(lambda x: x.get("access", 0), filtered_by_id)))


def get_tag_types(client: AuthenticatedClient) -> List[TagType]:
    resp = client.get("/tag/all")
    resp.raise_for_status()

    data = cast(List[Dict[str, str]], resp.json())

    if not data or len(data) == 0:
        return []

    return [
        TagType(
            id=UUID(tagtype["uuid"], version=4),
            name=tagtype["name"],
            data_type=DataType(tagtype["datatype"]),
        )
        for tagtype in data
    ]


def delete_tag(client: AuthenticatedClient, id: UUID) -> None:
    resp = client.delete(f"{TAG}/{id}")
    resp.raise_for_status()
    print(f"deleted tag {id} successfully")


def get_users(client: AuthenticatedClient) -> list[User]:
    resp = client.get(ALL_USERS)
    resp.raise_for_status()

    ret = []
    for user in cast(List[Dict[str, str]], resp.json()):
        user_model = User(
            id=UUID(user["uuid"], version=4),
            name=user["name"],
            email=user["email"],
            role=user["role"],
        )
        ret.append(user_model)
    return ret


def get_user_info(client: AuthenticatedClient) -> Any:
    resp = client.get(USER_INFO)
    resp.raise_for_status()
    return resp.json()


def promote_user(client: AuthenticatedClient, email: str) -> None:
    resp = client.post(PROMOTE_USER, json={"email": email})
    resp.raise_for_status()


def demote_user(client: AuthenticatedClient, email: str) -> None:
    resp = client.post(DEMOTE_USER, json={"email": email})
    resp.raise_for_status()
    print("User demoted.")


def get_file_download(client: AuthenticatedClient, id: UUID) -> str:
    """\
    get the download url for a file by file id
    """
    resp = client.get(FILE_DOWNLOAD, params={"uuid": str(id), "expires": True})

    if 400 <= resp.status_code < 500:
        raise AccessDeniedException(
            f"Failed to download file: {resp.json()['message']}",
            "Status Code: " + str(resp.status_code),
        )

    resp.raise_for_status()

    return resp.text


def _parse_file(file: Dict[str, Any]) -> File:
    project_id = UUID(file["mission"]["project"]["uuid"], version=4)
    project_name = file["mission"]["project"]["name"]

    mission_id = UUID(file["mission"]["uuid"], version=4)
    mission_name = file["mission"]["name"]

    filename = file["filename"]
    file_id = UUID(file["uuid"], version=4)
    file_size = file["size"]
    file_hash = file["hash"]

    parsed = File(
        id=file_id,
        name=filename,
        size=file_size,
        hash=file_hash,
        project_id=project_id,
        project_name=project_name,
        mission_id=mission_id,
        mission_name=mission_name,
    )
    return parsed


def get_file(client: AuthenticatedClient, id: UUID) -> File:
    resp = client.get(FILE_ONE, params={"uuid": str(id)})
    resp.raise_for_status()
    return _parse_file(resp.json())


def get_files(
    client: AuthenticatedClient,
    name: Optional[str] = None,
    project: Optional[str] = None,
    mission: Optional[str] = None,
    topics: Optional[List[str]] = None,
    tags: Optional[Dict[str, str]] = None,
) -> List[File]:
    # TODO: allow to search by id

    params: Dict[str, Any] = {"take": MAX_PAGINATION}
    if name is not None:
        params["name"] = name
    if project is not None:
        params["projectName"] = project
    if mission is not None:
        params["missionName"] = mission
    if topics:
        params["topics"] = ",".join(topics)
    if tags:
        params["tags"] = tags

    resp = client.get(FILE_QUERY, params=params)
    resp.raise_for_status()

    files = []
    data = resp.json()

    for file in data:
        try:
            parsed = _parse_file(file)
            files.append(parsed)
        except Exception:
            print(f"Error parsing file: {file}")
    return files


def confirm_file_upload(
    client: AuthenticatedClient, file_id: UUID, file_hash: str
) -> None:
    data = {
        "uuid": str(file_id),
        "md5": file_hash,
    }
    resp = client.post("/file/confirmUpload", json=data)

    if 400 <= resp.status_code < 500:
        raise CorruptedFile()
    resp.raise_for_status()
