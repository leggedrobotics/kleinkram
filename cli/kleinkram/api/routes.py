"""\
this file contains any functions calling the API
"""

from __future__ import annotations

from typing import Any
from typing import cast
from typing import Dict
from typing import List
from typing import Optional
from typing import Union
from uuid import UUID

from kleinkram.api.client import AuthenticatedClient
from kleinkram.error_handling import AccessDeniedException
from kleinkram.models import Project
from kleinkram.models import User
from kleinkram.tag import DataType
from kleinkram.tag import TagType
from kleinkram.utils import is_valid_uuid4
from kleinkram.utils import UploadAccess

TEMP_CREDS = "/file/temporaryAccess"
CLAIM_ADMIN = "/user/claimAdmin"

PROJECT_BY_NAME = "project/byName"
PROJECT_BY_ID = "project/one"
PROJECT_CREATE = "project/create"
PROJECTS_FILTERED = "project/filtered"

MISSION_BY_NAME = "mission/byName"
MISSION_BY_ID = "mission/one"
MISSION_CREATE = "mission/create"

TAG_TYPES = "/tag/all"
TAG = "/tag"

ALL_USERS = "/user/all"
USER_INFO = "/user/me"
PROMOTE_USER = "/user/promote"
DEMOTE_USER = "/user/demote"

FILE_DOWNLOAD = "/file/download"
FILE_QUERY = "/file/filteredByNames"


def get_upload_creditials(
    client: AuthenticatedClient, internal_filenames: List[str], mission_id: UUID
) -> Dict[str, UploadAccess]:
    if mission_id.version != 4:
        raise ValueError("Mission ID must be a UUIDv4")
    dct = {
        "filenames": internal_filenames,
        "missionUUID": str(mission_id),
    }
    resp = client.post(TEMP_CREDS, json=dct)

    if resp.status_code >= 400:
        raise ValueError(
            "Failed to get temporary credentials. Status Code: "
            f"{resp.status_code}\n{resp.json()['message'][0]}"
        )

    return resp.json()  # type: ignore


def claim_admin(client: AuthenticatedClient) -> None:
    """\
    the first user on the system could call this
    """
    response = client.post(CLAIM_ADMIN)
    response.raise_for_status()
    return


def get_project(
    client: AuthenticatedClient, identifier: Union[str, UUID]
) -> Union[tuple[UUID, Dict[str, Any]], tuple[None, None]]:

    if isinstance(identifier, UUID):
        params = {"uuid": str(identifier)}
    else:
        params = {"name": identifier}

    resp = client.get("/missions", params=params)

    if resp.status_code in (403, 404):
        return None, None

    # TODO: handle other status codes
    resp.raise_for_status()

    details = resp.json()
    return UUID(details["uuid"], version=4), details


def create_project(
    client: AuthenticatedClient,
    project_name: str,
    *,
    description: str | None = None,
    check_exists: bool = False,
) -> UUID:
    """\
    creates a new mission with the given name and project_id

    if check_exists is True, the function will return the existing mission_id,
    otherwise if the mission already exists an error will be raised
    """
    if description is None:
        description = "autogenerated by CLI"

    if check_exists:
        project_id, _ = get_project(client, project_name)
        if project_id is not None:
            return project_id

    if is_valid_uuid4(project_name):
        raise ValueError(
            f"Project name: `{project_name}` is a valid UUIDv4, "
            "project names must not be valid UUIDv4's"
        )

    resp = client.post(
        MISSION_CREATE,
        json={
            "name": project_name,
            "description": description,
            "requiredTags": [],
        },
    )

    if resp.status_code >= 400:
        raise ValueError(
            f"Failed to create project. Status Code: "
            f"{str(resp.status_code)}\n"
            f"{resp.json()['message'][0]}"
        )

    return UUID(resp.json()["uuid"], version=4)


def get_projects_filtered(client: AuthenticatedClient) -> list[Project]:
    resp = client.get(PROJECTS_FILTERED)
    resp.raise_for_status()

    ret = []
    for project in resp.json()[0]:
        id = UUID(project["uuid"], version=4)
        name = project["name"]
        description = project["description"]

        ret.append(Project(id=id, name=name, description=description))
    return ret


def get_mission(
    client: AuthenticatedClient, identifier: Union[str, UUID], project_id: UUID
) -> Optional[UUID]:

    if isinstance(identifier, UUID):
        params = {"uuid": str(identifier)}
    else:
        # ISSUE: https://github.com/leggedrobotics/kleinkram/issues/851
        params = {"name": identifier, "projectUUID": str(project_id)}

    resp = client.get("/missions", params=params)

    if resp.status_code in (403, 404):
        return None

    # TODO: handle other status codes
    resp.raise_for_status()

    return UUID(resp.json()["uuid"], version=4)


def create_mission(
    client: AuthenticatedClient,
    project_id: UUID,
    mission_name: str,
    *,
    check_exists: bool = False,
) -> UUID:
    """\
    creates a new mission with the given name and project_id

    if check_exists is True, the function will return the existing mission_id,
    otherwise if the mission already exists an error will be raised
    """

    if check_exists:
        mission_id = get_mission(client, mission_name, project_id)
        if mission_id is not None:
            return mission_id

    if is_valid_uuid4(mission_name):
        raise ValueError(
            f"Mission name: `{mission_name}` is a valid UUIDv4, "
            "mission names must not be valid UUIDv4's"
        )

    resp = client.post(
        MISSION_CREATE,
        json={
            "name": mission_name,
            "description": "Autogenerated by klein CLI",
            "requiredTags": [],
            "project_uuid": str(project_id),
        },
    )

    if resp.status_code >= 400:
        raise ValueError(
            f"Failed to create mission. Status Code: "
            f"{str(resp.status_code)}\n"
            f"{resp.json()['message'][0]}"
        )

    return UUID(resp.json()["uuid"], version=4)


def get_project_permission_level(client: AuthenticatedClient, project_id: UUID) -> int:
    """\
    we need this to check if a user has the permissions to
    create a mission in an existing project
    """

    resp = client.get("/user/permissions")
    resp.raise_for_status()

    project_group: List[Dict[str, Union[str, int]]] = resp.json().get("projects", [])
    filtered_by_id = filter(lambda x: x.get("uuid") == str(project_id), project_group)

    # it is possilbe that a user has access to a project via multiple groups
    # in this case we take the highest permission level
    return cast(int, max(map(lambda x: x.get("access", 0), filtered_by_id)))


def get_tag_types(client: AuthenticatedClient) -> List[TagType]:
    resp = client.get("/tag/all")
    resp.raise_for_status()

    data = cast(List[Dict[str, str]], resp.json())

    if not data or len(data) == 0:
        return []

    return [
        TagType(
            uuid=UUID(tagtype["uuid"], version=4),
            name=tagtype["name"],
            data_type=DataType(tagtype["datatype"]),
        )
        for tagtype in data
    ]


def delete_tag(client: AuthenticatedClient, id: UUID) -> None:
    resp = client.delete(f"{TAG}/{id}")
    resp.raise_for_status()
    print(f"deleted tag {id} successfully")


def get_users(client: AuthenticatedClient) -> list[User]:
    resp = client.get(ALL_USERS)
    resp.raise_for_status()

    ret = []
    for user in cast(List[Dict[str, str]], resp.json()):
        user_model = User(
            id=UUID(user["uuid"], version=4),
            name=user["name"],
            email=user["email"],
            role=user["role"],
        )
        ret.append(user_model)
    return ret


def get_user_info(client: AuthenticatedClient) -> Any:
    resp = client.get(USER_INFO)
    resp.raise_for_status()
    return resp.json()


def promote_user(client: AuthenticatedClient, email: str) -> None:
    resp = client.post(PROMOTE_USER, json={"email": email})
    resp.raise_for_status()


def demote_user(client: AuthenticatedClient, email: str) -> None:
    resp = client.post(DEMOTE_USER, json={"email": email})
    resp.raise_for_status()
    print("User demoted.")


def get_file_download(client: AuthenticatedClient, id: UUID) -> str:
    resp = client.get(FILE_DOWNLOAD, params={"uuid": str(id)})

    if 400 <= resp.status_code < 500:
        raise AccessDeniedException(
            f"Failed to download file: {resp.json()['message']}",
            "Status Code: " + str(resp.status_code),
        )

    resp.raise_for_status()
    return resp.text


def get_files(
    client: AuthenticatedClient,
    name: Optional[str] = None,
    mission: Optional[str] = None,
    topics: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
):
    if name is None and mission is None and topics is None and tags is None:
        raise ValueError("At least one of name, mission or topics must be provided")
